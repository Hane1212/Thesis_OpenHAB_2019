# 20190425: Add trigger to xml file
# This script allow to create trace in xml format
import re
import os
import time
import datetime
import xml.etree.ElementTree as ET
from xml.etree.ElementTree import Element, SubElement, Comment, tostring
from xml.dom import minidom
# from xml.dom.minidom import parseString
from collections import OrderedDict
import fileinput
import subprocess
from configparser import ConfigParser  
# from ElementTree_pretty import prettify

INFO = ' [INFO ]'
ROOT_report = 'ROOT_report'
ROOT_real = 'ROOT_real'
ROOT_test = 'ROOT_test'
FILE_DIR = 'FILE_DIR'
DURATION = 'DURATION'
Version = 'Version'
parseValue = []

generated_on = str(datetime.datetime.now())

# Get Argument from config.ini file
def getConfig(tag, item):
    config = ConfigParser() 
    config.read('config.ini') 
    temp_ = config.get(tag, item)
    return temp_

def getDir(root, item):
    """
    Render a directory to file.
    :return: file path 
    """
    dir_=''
    root_ = getConfig('FILE_DIR', root)
    ver = getConfig('DURATION', 'Version')
    type_ = getConfig('FILE_DIR', item)
    if 'test' in root:
        dir_ = root_+ver+'/'+item+'_test_'+ver+'.'+type_
        print(dir_)
    else: dir_ = root_+ver+'/'+item+'_'+ver+'.'+type_
    return dir_

def getTimeNow():
    currentDT = '{0:%Y%m%d_%H%M%S}'.format(datetime.datetime.now())
    return currentDT
# Write log in xml format
def prettify(elem, tfile):
    """Return a pretty-printed XML string for the Element."""
    # rough_string = ET.tostring(elem, 'utf-8', 'xml')
    rough_string = ET.tostring(elem).decode('utf-8')
    # print(rough_string)
    reparsed = minidom.parseString(rough_string)
    myfile = open(tfile, "w")  
    myfile.write(reparsed.toprettyxml(indent="\t"))
    # return reparsed.toprettyxml(indent="  ")

# Read data from log file then write trigger/rule/action to xml file
ruleGroup  = {}
def writeTrace(traceFile, cfile, start, stop):
    trace = Element('trace')
    trace.set('version', '1.0')
    trace.append(Comment('Generated by HuongTA for M2R Project'))
    head = SubElement(trace, 'head')
    title = SubElement(head, 'title')
    title.text = 'My smart home data'
    dc = SubElement(head, 'dateCreated')
    dc.text = generated_on
    body = SubElement(trace, 'body')
    rule = SubElement(body, 'body')
    trigger = SubElement(rule, 'body')
    state = SubElement(body, 'body')
    startTime = getConfig(DURATION, start)
    stopTime = getConfig(DURATION, stop)
    print(startTime)
    print(stopTime)
    count = 0
    c_state = 0
    with open (cfile, 'rt') as f:
        line = f.readlines()
        print(len(line))
        i=0     
        while i < len(line):  
            timeLog = getTime(line[i])    
            # print(timeLog)
            if '[INFO ]' in line[i]:
                while startTime < timeLog < stopTime:
                    timestamp, tagRule, value = getArg(line[i])  
                    if 'Trigger' in line[i]:
                        item, state_ = getState(value)
                        trigger = SubElement(rule, 'trigger', OrderedDict([('time', timestamp),('item', item), ('state', state_)]))   
                        # tst, tR, v = getArg(line[i+1])
                        j=i
                        while 'Rule:' not in line[j]:
                            j=j+1
                        if 'Rule:' in line[j]:
                            tst, tR, v = getArg(line[j+1])
                        tagTriger =  tR+'Trigger'   
                        ruleGroup[tagTriger] = trigger                
                    elif 'START' in line[i]:
                        count = count+1
                        rule_ = SubElement(trigger, 'rule', OrderedDict([('state', 'START'), ('rule', tagRule)]))
                        # rule_ = SubElement(trigger, 'rule', OrderedDict([('Order', str(count)), ('state', 'START'), ('rule', tagRule)]))
                        ruleGroup[tagRule] = rule_
                    elif 'FINISH' in line[i]:
                        temp = tagRule+'Trigger'
                        trigger_= ruleGroup.get(temp)
                        if trigger_ != None: 
                            SubElement(trigger_, 'rule', OrderedDict([('state', 'FINISH'), ('rule', tagRule)]))
                            # del ruleGroup[tagRule]
                            del ruleGroup[temp]
                        else:
                            SubElement(trigger, 'rule', OrderedDict([('state', 'FINISH'), ('rule', tagRule)]))  
                    elif 'Rule:' in line[i] and 'SLEEP' not in line[i]: 
                        rule_= ruleGroup.get(tagRule)
                        if rule_ != None: 
                            SubElement(rule_, 'action', OrderedDict([('action', value)]))
                        else:
                            SubElement(trigger, 'action', OrderedDict([('action', value)]))
                    elif 'STATE' in tagRule:
                        c_state = c_state+1
                        item, state_ = getState(value)
                        # SubElement(state, 'state', OrderedDict([('state', tagRule), ('Order', str(c_state)),  ('item', value)]))
                        SubElement(state, 'state', OrderedDict([('time', timestamp), ('item', item), ('state', state_)]))
                    i=i+1
                    timeLog = getTime(line[i])
                if timeLog > stopTime:
                    i = len(line)
                i=i+1
            else:
                i=i+1
    prettify(trace, traceFile)

# Get time in log line
def getTime(line):
    getT = []
    try:
        getT = line.split(' [')
    except Exception as e:
        print(e)
    return getT[0]

def newLine(i, line, body):
    if (i == len(line)-1):
        getEvent(line[i], body)
    else:
        i=i+1 
    return i
# Get state of item in log line
def getState(v):
    get = []
    get  = v.split(' changed to ')
    return get[0], get[1]
# General event
def getEvent(line, parent):
    timestamp, tag, value=getArg(line)
    SubElement(parent, 'event', OrderedDict([('timestamp', timestamp), ('tag', tag), ('event', value)]))    
# Return time/tag/value of log line
def getArg(line):
    parseValue = parseLine(line)
    timestamp = parseValue[0]
    tag = parseValue[2]
    value = parseValue[1]
    return timestamp, tag, value
# Analysis line to get data
def parseLine(line):
    getV = []
    if '[' not in line:
        print(line)
    else:
        timestamp = line.split(' [')[0]
        getV.append(timestamp)
        temp_value = line.split(' - ')
        value = temp_value[len(temp_value)-1].strip()
        getV.append(value)
        if INFO in line:
            temp_value = line.split(INFO)[1]
            tag = temp_value[temp_value.find('[')+1 : temp_value.find(']')]
            temp_ = tag.split('.')
            tag = temp_[len(temp_)-1]
        else:
            tag = line[line.find('[')+1 : line.find(']')]
        getV.append(tag)
        return getV

important = []
# Filter line with INFO in openhab.log
def getINFOLog():
    INFO_temp = getConfig('FILE_DIR', 'INFO_temp')
    openHABlog = getConfig('FILE_DIR', 'openHABlog')
    try:
        exists = os.path.isfile(INFO_temp)
        if exists:
            os.remove(INFO_temp)
    except Exception as e:
        print(e)

    with open(openHABlog) as f:
        f = f.readlines()
        for line in f:
            if INFO in line:
                important.append(line)
    with open(INFO_temp, 'a') as ilog:
        for i in important:
            ilog.write(i)
# File CMD.log with time format include ',' => replace ',' by '.'
def makeTimeFormat(f):
    # Read in the file
    log_CMD_temp = getConfig('FILE_DIR','log_CMD')
    with open(log_CMD_temp, 'r') as file :
        filedata = file.read()
        # Replace the target string
        filedata = filedata.replace(',', '.')
    # Write the file out again
    with open(f, 'w') as file:
        file.write(filedata)

def initial():
    root_report = getConfig(FILE_DIR, ROOT_report)
    root_real = getConfig(FILE_DIR, ROOT_real)
    root_test = getConfig(FILE_DIR, ROOT_test)
    ver = getConfig(DURATION, Version)
    if os.path.exists(root_report+'/'+ver)==False: 
        os.mkdir(root_report+'/'+ver)
        os.mkdir(root_report+'/'+ver +'/State')
        os.mkdir(root_report+'/'+ver +'/State_test')
    if os.path.exists(root_real+'/'+ver) == False : 
        os.mkdir(root_real+'/'+ver)
        os.mkdir(root_real+'/'+ver+'/State')
        os.mkdir(root_real+'/'+ver+'/State_test')
    if os.path.exists(root_test+'/'+ver) == False : 
        os.mkdir(root_test+'/'+ver)
        os.mkdir(root_test+'/'+ver+'/State')
        os.mkdir(root_test+'/'+ver+'/State_test')  

def main():
    # initial()
    openHABlog_test = getConfig(FILE_DIR, 'openHABlog_test')
    trace_test = getDir(ROOT_test, 'trace')
    writeTrace(trace_test, openHABlog_test, 'startTime_test', 'stopTime_test')
   
    openHABlog = getConfig(FILE_DIR, 'openHABlog')
    trace = getDir(ROOT_real, 'trace')
    writeTrace(trace, openHABlog, 'startTime', 'stopTime')

if __name__ == "__main__":
    main()
    
